# 数学

- [数学](#数学)
  - [进制](#进制)
    - [二进制小数的表示](#二进制小数的表示)
  - [数组](#数组)


## 进制

### 二进制小数的表示

[LeetCode 面试题 05.02. 二进制数转字符串](https://leetcode.cn/problems/bianry-number-to-string-lcci/submissions/)

设十进制小数 $num$ 的二进制表示为 $0.b_1b_2b_3\cdots b_k$ ，考虑将其转为二进制字符串

每次乘 $2$ 将小数点向右移动一位，变为 $b_1.b_2b_3\cdots b_k$，将 $b_1$ 记录下来并减去，至多循环 $32$ 次。如果 $num$ 最终变为 $0$ ，那么便可以直接返回

不难写出如下代码：

```cpp
class Solution {
public:
    string printBin(double num) 
    {
        string ans = "0.";
        for(int i = 0; i < 32; i ++)
        {
            num *= 2;
            if(num < 1)
            {
                ans += "0";
            }
            else
            {
                ans += "1";
                if(--num == 0) return ans;
            }
        }
        return "ERROR";
    }
};
```

优化：

* 任何一个**有限位** $p$ 进制小数均可以表示成**最小分数** $\frac{a}{p^k}$ ，其中 $a$ 和 $p^k$ 互质

$num$ 最多为十进制**六位**小数，设其表示为 $\frac{a}{10^6}$ ，设其对应二进制表示为 $\frac{b}{2^k}$ ，有：

$$
\frac{a}{10^6}=\frac{b}{2^k} \rightarrow
\frac{a}{2^65^6}=\frac{b}{2^k} \rightarrow
b=\frac{a2^{k-6}}{5^6}
$$

由于 $b$ 与 $2$ 互质，因此 $0\le k\le 6$ ，即对于六位十进制小数而言，其对应二进制小数最多只有六位，因此只需要枚举 $6$ 次即可

完整代码：

```cpp
class Solution {
public:
    string printBin(double num) 
    {
        string ans = "0.";
        for(int i = 0; i < 6; i ++)
        {
            num *= 2;
            if(num < 1)
            {
                ans += "0";
            }
            else
            {
                ans += "1";
                if(--num == 0) return ans;
            }
        }
        return "ERROR";
    }
};
```

## 数组

[LeetCode 1630. 等差子数组](https://leetcode.cn/problems/arithmetic-subarrays/)

这道题可以用最暴力的做法，每次将子数组进行排序，然后考虑子数组是否为等差数列，这里我们直接给出代码，不做过多讨论

```cpp
class Solution {
public:
    vector<bool> checkArithmeticSubarrays(vector<int>& nums, vector<int>& l, vector<int>& r) 
    {
        int n = nums.size(), m = l.size();
        vector<bool>ans(m, true);
        for(int i = 0; i < m; i ++)
        {
            vector<int>tmp(nums.begin() + l[i], nums.begin() + r[i] + 1);
            sort(tmp.begin(), tmp.end());
            int d = tmp[1] - tmp[0];
            for(int j = 2; j < tmp.size(); j ++)
            {
                if(tmp[j] - tmp[j - 1] != d)
                {
                    ans[i] = false;
                    break;
                }
            }
        }
        return ans;
    }
};
```

这么做的时间复杂度为：$O(mn\log n)$，其实有 $O(nm)$ 的做法

对于一个序列，设最大值为 $maxv$ ，最小值为 $minv$ ，元素个数为 $l$，如果从新排列使其能够成为等差序列，其公差必然为：

$$
\frac{maxv-minv}{l-1}
$$

如果无法整除，说明该序列无法构成等差数列

更进一步，我们需要确认将数从新排列后是否出现冲突，因此需要确认每个数在等差数列当中的位值，如果出现冲突则说明该序列无法构成等差数列

具体地，对于数 $x$ 而言，其在等差数列当中的位置为：

$$
idx=\frac{x-minv}{d}
$$

因此这一步我们可以开一个哈希表来判断是否出现冲突，如果都没有出现冲突，则说明该子数组重新排列后可以构成等差数列

完整代码如下：

```cpp
class Solution {
public:
    vector<bool> checkArithmeticSubarrays(vector<int>& nums, vector<int>& l, vector<int>& r) 
    {
        int n = nums.size(), m = l.size();
        vector<bool>ans;
        for(int i = 0; i < m; i ++)
        {
            int left = l[i], right = r[i];
            int maxv = *max_element(nums.begin() + left, nums.begin() + right + 1);
            int minv = *min_element(nums.begin() + left, nums.begin() + right + 1);
            if((maxv - minv) % (right - left) != 0)//无法整除的情况
            {
                ans.push_back(false);
                continue;
            }
            if(maxv == minv)//数列中每个数都相同
            {
                ans.push_back(true);
                continue;
            }
            int d = ((maxv - minv) / (right - left));
            bool flag = true;
            vector<int>hash(right - left + 1, 0);
            for(int j = left; j <= right; j ++)
            {
                if((nums[j] - minv) % d != 0)//无法整除的情况
                {
                    flag = false;
                    break;
                }
                int t = (nums[j] - minv) / d;
                if(hash[t])
                {
                    flag = false;
                    break;
                }
                else hash[t]++;
            }
            ans.push_back(flag);
        }
        return ans;
    }
};
```