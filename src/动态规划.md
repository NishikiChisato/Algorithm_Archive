# 动态规划

- [动态规划](#动态规划)
  - [线性 DP](#线性-dp)
    - [数字三角形](#数字三角形)
      - [基本：](#基本)
      - [变式：](#变式)
    - [最长上升子序列 (LIS)](#最长上升子序列-lis)
      - [基本：](#基本-1)
      - [变式：](#变式-1)
    - [求可变序列与给定数 $N$ 同余的方案数](#求可变序列与给定数-n-同余的方案数)
  - [背包](#背包)
    - [基础：](#基础)
    - [变式：](#变式-2)
      - [单调队列优化多重背包](#单调队列优化多重背包)
      - [二维费用背包问题](#二维费用背包问题)
  - [状态机 DP](#状态机-dp)
    - [基础：](#基础-1)
    - [变式：](#变式-3)
  - [状态压缩 DP](#状态压缩-dp)
    - [基础](#基础-2)
    - [变式](#变式-4)
  - [区间 DP](#区间-dp)
    - [基础](#基础-3)
    - [变式](#变式-5)
  - [树形 DP](#树形-dp)
    - [基础](#基础-4)
    - [变式](#变式-6)
  - [数位 DP](#数位-dp)
    - [基础](#基础-5)
  - [其余](#其余)
    - [求可变序列与给定数 $N$ 同余的方案数](#求可变序列与给定数-n-同余的方案数-1)


<details>
<summary>相关问题总结</summary>

单调队列中，**只需考虑队头元素**：[单调队列优化多重背包](#单调队列优化多重背包)

单调队列中，**需要考虑所有元素**：

</details>

---

## 线性 DP

### 数字三角形

#### 基本：

[AcWing 1015. 摘花生](https://www.acwing.com/solution/content/160295/)

#### 变式：

[AcWing 1018. 最低通行费](https://www.acwing.com/solution/content/160302/)

[AcWing 1027. 方格取数](https://www.acwing.com/solution/content/160313/)

[AcWing 275. 传纸条](https://www.acwing.com/solution/content/160368/)


### 最长上升子序列 (LIS)

#### 基本：

[AcWing 895. 最长上升子序列](https://www.acwing.com/solution/content/160375/)

[AcWing 896. 最长上升子序列 II](https://www.acwing.com/solution/content/160399/)

[AcWing 897. 最长公共子序列](https://www.acwing.com/solution/content/160673/)

#### 变式：

[AcWing 1017. 怪盗基德的滑翔翼](https://www.acwing.com/solution/content/160425/)

[AcWing 1014. 登山](https://www.acwing.com/solution/content/160435/)

[AcWing 482. 合唱队形](https://www.acwing.com/solution/content/160440/)

[AcWing 1012. 友好城市](https://www.acwing.com/solution/content/160463/)

[AcWing 1016. 最大上升子序列和](https://www.acwing.com/solution/content/160500/)

[AcWing 1010. 拦截导弹](https://www.acwing.com/solution/content/160633/) 

[AcWing 187. 导弹防御系统](https://www.acwing.com/solution/content/160652/)  

[AcWing 272. 最长公共上升子序列](https://www.acwing.com/solution/content/161001/)

### 求可变序列与给定数 $N$ 同余的方案数

原题链接：[AcWing 1214. 波动数列](https://www.acwing.com/problem/content/description/1216/)

题解链接：[AcWing 1214. 波动数列](https://www.acwing.com/solution/content/171496/)

我们设数列第一项为 $x$ ，第二项为 $x+d_1$ ，第 $i$ 项为 $x+d_1+d_2+\cdots +d_{i-1}$ ，那么对于长度为 $n$ 的序列和为 $s=x+(x+d_1)+(x+d_1+d_2)+\cdots +(x+d_1+d_2+\cdots +d_{i-1})$ ，即：

$$
s=nx+(n-1)d_1+(n-2)d_2+\cdots +(n-i)d_i+\cdots +d_{n-1},\ \ d_i \in \\{a,-b\\}
$$

此时问题转变成：对于给定的每个 $s$ 与 $n$ ，在 $d_i$ 任意取值的情况下，等式成立的个数

由于 $x\in Z$ ，并且当 $d_i$ 全部唯一确定时， $x$ 也会唯一确定。此时我们需要确定的是，当 $d_i$ 取哪些值时 $x$ 是合法的（处于整数范围内），因此有如下等式：

$$
x=\frac{s-[(n-1)d_1+(n-2)d_2+\cdots +(n-i)d_i+\cdots +d_{n-1}]}{n}
$$

如果 $x$ 要落在整数范围内，那么 $s$ 与 $(x-1)d_1+(n-2)d_2+\cdots +(n-i)d_i+\cdots +d_{n-1}$ 必须**模 $n$ 同余**

此时问题转换成：对于序列 $(n-1)d_1+(n-2)d_2+\cdots +(n-i)d_i+\cdots +d_{n-1}$ 与 $s$ 模 $n$ 同余的个数

考虑动态规划，$f[i][j]$ 表示对第 $i$ 个数选择，模 $n$ 余 $j$ 的方案数

第 $i$ 个数对应 $d_i$ ，系数为 $(n-i)$ ，因此：

* 若第 $i$ 个数为 $a$ ，即 $d_i=a$ ，有 $(n-1)d_1+(n-2)d_2+\cdots +(n-i)a$ ，即 $f[i-1][\mod((j-(n-i)*a), \ n)]$

* 同理，若第 $i$ 个数为 $-b$ ，有 $f[i-1][\mod((j+(n-i)*b),\ n)]$

最终结果为 $f[n-1][\mod(s,\  n)]$

完整代码如下：

```cpp
#include <iostream>
using namespace std;

const int N = 1e3 + 10, mod = 1e8 + 7;

int get_mod(int a, int n)
{
    return (a % n + n) % n;
}

int f[N][N];

int n, s, a, b;

int main()
{
    cin >> n >> s >> a >> b;
    f[0][0] = 1;
    for(int i = 1; i <= n - 1; i++)
    {
        for(int j = 0; j < n; j++)
        {
            f[i][j] = get_mod(f[i][j] + f[i - 1][get_mod(j - (n - i) * a, n)], mod);
            f[i][j] = get_mod(f[i][j] + f[i - 1][get_mod(j + (n - i) * b, n)], mod);
        }
    }
    cout << f[n - 1][get_mod(s, n)] << endl;
    return 0;
}
```



## 背包

### 基础：

[AcWing 2. 01背包问题](https://www.acwing.com/solution/content/160731/)

[AcWing 3. 完全背包问题](https://www.acwing.com/solution/content/160739/)

[AcWing 4. 多重背包问题 I](https://www.acwing.com/solution/content/161548/)

[AcWing 5. 多重背包问题 II](https://www.acwing.com/solution/content/161550/)

[AcWing 9. 分组背包问题](https://www.acwing.com/solution/content/161675/)

[AcWing 7. 混合背包问题](https://www.acwing.com/solution/content/162133/)

### 变式：

[AcWing 423. 采药](https://www.acwing.com/solution/content/161034/)

[AcWing 1024. 装箱问题](https://www.acwing.com/solution/content/161044/)

[AcWing 1022. 宠物小精灵之收服](https://www.acwing.com/solution/content/161087/)

[AcWing 278. 数字组合](https://www.acwing.com/solution/content/161112/)

#### 单调队列优化多重背包

[AcWing 6. 多重背包问题 III](https://www.acwing.com/solution/content/161559/)

#### 二维费用背包问题

[AcWing 8. 二维费用的背包问题](https://www.acwing.com/solution/content/161568/)

[AcWing 1019. 庆功会](https://www.acwing.com/solution/content/161601/)

[AcWing 1023. 买书](https://www.acwing.com/solution/content/161607/)

[AcWing 1020. 潜水员](https://www.acwing.com/solution/content/161636/) 

[AcWing 12. 背包问题求具体方案](https://www.acwing.com/solution/content/161862/)

[AcWing 1013. 机器分配](https://www.acwing.com/solution/content/161865/)

[AcWing 426. 开心的金明](https://www.acwing.com/solution/content/161888/)

[AcWing 487. 金明的预算方案](https://www.acwing.com/solution/content/161890/)

[AcWing 1021. 货币系统](https://www.acwing.com/solution/content/161900/)

[AcWing 532. 货币系统](https://www.acwing.com/solution/content/161915/)

[AcWing 10. 有依赖的背包问题](https://www.acwing.com/solution/content/162165/)

[AcWing 11. 背包问题求方案数](https://www.acwing.com/solution/content/162227/)

[AcWing 734. 能量石](https://www.acwing.com/solution/content/162238/)

## 状态机 DP

### 基础：

[AcWing 1049. 大盗阿福](https://www.acwing.com/solution/content/162297/)

### 变式：

[AcWing 1057. 股票买卖 IV](https://www.acwing.com/solution/content/162504/)

[AcWing 1058. 股票买卖 V](https://www.acwing.com/solution/content/162508/)

## 状态压缩 DP

### 基础

[AcWing 1064. 小国王](https://www.acwing.com/solution/content/163151/)

### 变式

[AcWing 327. 玉米田](https://www.acwing.com/solution/content/163158/)

[AcWing 292. 炮兵阵地](https://www.acwing.com/solution/content/163166/)

[AcWing 524. 愤怒的小鸟](https://www.acwing.com/solution/content/163228/)

## 区间 DP

### 基础

[AcWing 282. 石子合并](https://www.acwing.com/solution/content/163255/)

### 变式

[AcWing 1068. 环形石子合并](https://www.acwing.com/solution/content/163270/)

[AcWing 320. 能量项链](https://www.acwing.com/solution/content/165951/)

[AcWing 1069. 凸多边形的划分](https://www.acwing.com/solution/content/165959/)

[AcWing 479. 加分二叉树](https://www.acwing.com/solution/content/165967/)

[AcWing 321. 棋盘分割](https://www.acwing.com/solution/content/165998/)

## 树形 DP

### 基础

[AcWing 285. 没有上司的舞会](https://www.acwing.com/solution/content/162141/)

[AcWing 1072. 树的最长路径](https://www.acwing.com/solution/content/166013/)

[AcWing 1073. 树的中心](https://www.acwing.com/solution/content/166199/)

### 变式

[AcWing 1075. 数字转换](https://www.acwing.com/solution/content/166203/)

[AcWing 1074. 二叉苹果树](https://www.acwing.com/solution/content/166236/)

[AcWing 323. 战略游戏](https://www.acwing.com/solution/content/166250/)

[AcWing 1077. 皇宫看守](https://www.acwing.com/solution/content/166277/)

## 数位 DP

### 基础

[AcWing 1081. 度的数量](https://www.acwing.com/solution/content/166312/)

## 其余

### 求可变序列与给定数 $N$ 同余的方案数

原题链接：[AcWing 1214. 波动数列](https://www.acwing.com/problem/content/description/1216/)

题解链接：[AcWing 1214. 波动数列](https://www.acwing.com/solution/content/171496/)

我们设数列第一项为 $x$ ，第二项为 $x+d_1$ ，第 $i$ 项为 $x+d_1+d_2+\cdots +d_{i-1}$ ，那么对于长度为 $n$ 的序列和为 $s=x+(x+d_1)+(x+d_1+d_2)+\cdots +(x+d_1+d_2+\cdots +d_{i-1})$ ，即：

$$
s=nx+(n-1)d_1+(n-2)d_2+\cdots +(n-i)d_i+\cdots +d_{n-1},\ \ d_i \in \\{a,-b\\}
$$

此时问题转变成：对于给定的每个 $s$ 与 $n$ ，在 $d_i$ 任意取值的情况下，等式成立的个数

由于 $x\in Z$ ，并且当 $d_i$ 全部唯一确定时， $x$ 也会唯一确定。此时我们需要确定的是，当 $d_i$ 取哪些值时 $x$ 是合法的（处于整数范围内），因此有如下等式：

$$
x=\frac{s-[(n-1)d_1+(n-2)d_2+\cdots +(n-i)d_i+\cdots +d_{n-1}]}{n}
$$

如果 $x$ 要落在整数范围内，那么 $s$ 与 $(x-1)d_1+(n-2)d_2+\cdots +(n-i)d_i+\cdots +d_{n-1}$ 必须**模 $n$ 同余**

此时问题转换成：对于序列 $(n-1)d_1+(n-2)d_2+\cdots +(n-i)d_i+\cdots +d_{n-1}$ 与 $s$ 模 $n$ 同余的个数

考虑动态规划，$f[i][j]$ 表示对第 $i$ 个数选择，模 $n$ 余 $j$ 的方案数

第 $i$ 个数对应 $d_i$ ，系数为 $(n-i)$ ，因此：

* 若第 $i$ 个数为 $a$ ，即 $d_i=a$ ，有 $(n-1)d_1+(n-2)d_2+\cdots +(n-i)a$ ，即 $f[i-1][\mod((j-(n-i)*a), \ n)]$

* 同理，若第 $i$ 个数为 $-b$ ，有 $f[i-1][\mod((j+(n-i)*b),\ n)]$

最终结果为 $f[n-1][\mod(s,\  n)]$

完整代码如下：

```cpp
#include <iostream>
using namespace std;

const int N = 1e3 + 10, mod = 1e8 + 7;

int get_mod(int a, int n)
{
    return (a % n + n) % n;
}

int f[N][N];

int n, s, a, b;

int main()
{
    cin >> n >> s >> a >> b;
    f[0][0] = 1;
    for(int i = 1; i <= n - 1; i++)
    {
        for(int j = 0; j < n; j++)
        {
            f[i][j] = get_mod(f[i][j] + f[i - 1][get_mod(j - (n - i) * a, n)], mod);
            f[i][j] = get_mod(f[i][j] + f[i - 1][get_mod(j + (n - i) * b, n)], mod);
        }
    }
    cout << f[n - 1][get_mod(s, n)] << endl;
    return 0;
}
```